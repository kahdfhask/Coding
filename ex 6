#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX 100
#define GOODS_FILE_NAME "goodsinfo.txt"

#define MAX_ID_LEN 30
#define MAX_NAME_LEN 30
#define MAX_PRICE_LEN 30
#define MAX_DISCOUNT_LEN 30
typedef struct {
	char    goods_id[MAX_ID_LEN];
	char    goods_name[MAX_NAME_LEN];
	int     goods_price;
	char    goods_discount[MAX_DISCOUNT_LEN];
	int     goods_amount;
	int     goods_remain;
} GoodsInfo;

typedef struct node
{
	GoodsInfo data;
	struct node *next;
} GoodsList;



//全局变量，存储当前商品的数量
int CurrentCnt;

void init_list(GoodsList **L) {
	FILE *fp;
	GoodsInfo goodsInfo;
	GoodsList *p, *r;

	(*L) = (GoodsList *)malloc(sizeof(GoodsList));
	r = (*L);
	if ((fp = fopen(GOODS_FILE_NAME, "r")) == NULL)
	{
		if ((fp = fopen(GOODS_FILE_NAME, "w")) == NULL)
			printf("提示：不能创建商品文件\n");
	}
	else {
		while (!feof(fp))
		{
			fscanf(fp, "%s", goodsInfo.goods_id);
			fscanf(fp, "\t%s", goodsInfo.goods_name);
			fscanf(fp, "\t%d", &goodsInfo.goods_price);
			fscanf(fp, "\t%s", goodsInfo.goods_discount);
			fscanf(fp, "\t%d", &goodsInfo.goods_amount);
			fscanf(fp, "\t%d\n", &goodsInfo.goods_remain);
			p = (GoodsList*)malloc(sizeof(GoodsList));
			p->data = goodsInfo;
			r->next = p;
			r = p;
			CurrentCnt++;
		}
	}
	fclose(fp);
	r->next = NULL;
	printf("商品的链表文件已建立，有%d个商品记录\n", CurrentCnt);
}

//-------------------------------------------------------------
//以行读取输入的信息
//-------------------------------------------------------------
int read_line(char str[], int n)
{
	int ch, i = 0;

	while (isspace(ch = getchar()))
		;
	while (ch != '\n' && ch != EOF) {
		if (i < n)
			str[i++] = ch;
		ch = getchar();
	}
	str[i] = '\0';
	return i;
}

GoodsInfo read_goods_info(){
	GoodsInfo goodsInfo;
	printf("输入你要插入的商品信息：\n");
	printf("商品ID：");
	read_line(goodsInfo.goods_id, MAX_ID_LEN);
	printf("商品名称：");
	read_line(goodsInfo.goods_name, MAX_NAME_LEN);
	printf("商品价格：");
	scanf("%d",&goodsInfo.goods_price);
	printf("商品折扣：");
	read_line(goodsInfo.goods_discount, MAX_DISCOUNT_LEN);
	printf("商品数量：");
	scanf("%d", &goodsInfo.goods_amount);
	printf("商品剩余：");
	scanf("%d", &goodsInfo.goods_remain);
	return goodsInfo;
}

//-------------------------------------------------------------
//添加一条商品记录
//-------------------------------------------------------------
bool insert_item(GoodsList *L, GoodsInfo goodsInfo, int choice) {
	GoodsList *temp;
	GoodsList *pre = L, *p = L->next;
	int i;
	if (CurrentCnt >= 100) {
		printf("信息库已满，要插入请先删除一定量的商品数据!\n");
		return false;
	}
	switch (choice) {
		case 0:
			//尾插法插入新商品
			while (p != NULL)
			{
				pre = p;
				p = p->next;
			}
			temp = (GoodsList*)malloc(sizeof(GoodsList));
			temp->data = goodsInfo;
			pre->next = temp;
			temp->next = NULL;
			printf("Tips:添加商品%s成功\n", goodsInfo.goods_name);
			CurrentCnt++;
			return true;
		case 1:
			//头插法插入新商品
			temp = (GoodsList*)malloc(sizeof(GoodsList));
			temp->data = goodsInfo;
			temp->next = L->next;
			L->next = temp;
			printf("Tips:添加商品%s成功\n", goodsInfo.goods_name);
			CurrentCnt++;
			return true;
		default:
			//中间i号位置插入新商品，例如：输入3，应该在第二个节点后插入新节点
			// CurrentCnt 改为 CurrentCnt+1，因为当 CurrentCnt 为2时，链表中有两个记录，
			// 此时输入3，即 choise为 3，表示在第二条记录后插入数据，新记录成为第3条数据
			if (choice <= CurrentCnt+1 && choice > 0) {
				for (i = 1; i < choice; i++) {
					pre = p;
					p = p->next;
				}
				temp = (GoodsList*)malloc(sizeof(GoodsList));
				temp->data = goodsInfo;
				pre->next = temp;
				temp->next = p;
				printf("Tips:添加商品%s成功\n", goodsInfo.goods_name);
				CurrentCnt++;
				return true;
			}
			else {
				printf("输入的位置超出当前商品列表范围\n");
				return false;
			}
	}
}


//-------------------------------------------------------------
//删除一条商品记录
//-------------------------------------------------------------
bool delete_item(GoodsList *L, char* goods_id) {
	GoodsList *pre = L, *p = L->next;
	while (p != NULL && (strcmp(p->data.goods_id, goods_id))) {
		pre = p;
		p = p->next;
	}
	if (p == NULL) {
		return false;
	}
	else
	{
		pre->next = p->next;
		free(p);
		CurrentCnt--;
		return true;
	}
}


//-------------------------------------------------------------
//查找一条商品记录
//-------------------------------------------------------------

GoodsList* search_item(GoodsList *L, char* goods_id) {
	GoodsList *p = L->next;
	if (strcmp(goods_id, "-1") == 0)
		return NULL;
	while (p != NULL && (strcmp(p->data.goods_id, goods_id))) {
		p = p->next;
	}
	return p;
}

//-------------------------------------------------------------
//修改一条商品记录
//-------------------------------------------------------------
bool change_item(GoodsList *L, char* goods_id, GoodsInfo new_info) {
	GoodsList *p = L->next;
	GoodsList *ptarget = search_item(L, goods_id);
	if (ptarget == NULL) {
		return false;
	}
	else
	{
		strcpy(ptarget->data.goods_id, new_info.goods_id);
		strcpy(ptarget->data.goods_name, new_info.goods_name);
		ptarget->data.goods_price = new_info.goods_price;
		strcpy(ptarget->data.goods_discount, new_info.goods_discount);
		ptarget->data.goods_amount = new_info.goods_amount;
		ptarget->data.goods_remain = new_info.goods_remain;
		return true;
	}
}


//-------------------------------------------------------------
//打印单个商品链表节点的信息
//-------------------------------------------------------------
void output_one_item(GoodsList *p){
	if(p == NULL)
		return;
	printf("ID:%s\t名称:%s\t价格:%3d\t折扣:%s\t数量:%d\t剩余:%d\n",
	       p->data.goods_id, p->data.goods_name, p->data.goods_price, p->data.goods_discount,
	       p->data.goods_amount, p->data.goods_remain);
}


//-------------------------------------------------------------
//在屏幕上输出所有商品信息
//-------------------------------------------------------------

void output_all_items(GoodsList *L)
{
	// GoodsList *pre = L, *p = L->next;
	// int i; //commented by bzj
	GoodsList *p = L->next;
	//printf("当前有%d个商品\n", CurrentCnt);
	while (p != NULL) {
		output_one_item(p);
		p = p->next;
	}
}

//-------------------------------------------------------------
//释放商品链表
//-------------------------------------------------------------
void destory_list(GoodsList **L) {
	if (L == NULL || *L == NULL)
		return;
	GoodsList *pre = *L, *p = (*L)->next;
	while (p != NULL)
	{
		free(pre);
		pre = p;
		p = p->next;
	}
	free(pre);
	CurrentCnt = 0;
	*L = NULL;
}


//-------------------------------------------------------------
//删除商品文件以及商品链表中的所有信息
//-------------------------------------------------------------

void destory_list_and_file(GoodsList **L) {
	destory_list(L);
	remove(GOODS_FILE_NAME);
}

//-------------------------------------------------------------
//将当前商品链表中的内容存入商品文件goodsinfo.txt，返回商品的个数
//-------------------------------------------------------------
int save_to_file(GoodsList *L) {
	if(L == NULL)
		return 0;
	GoodsList *p = L->next;
	FILE *fp;
	if ((fp = fopen("goodsinfo.txt", "w")) == NULL)
	{
		printf("提示：不能打开商品文件\n");
		return 0;
	}
	int save_count = 0;
	while (p != NULL)
	{
		fprintf(fp, "%s\t", p->data.goods_id);
		fprintf(fp, "%s\t", p->data.goods_name);
		fprintf(fp, "%d\t", p->data.goods_price);
		fprintf(fp, "%s\t", p->data.goods_discount);
		fprintf(fp, "%d\t", p->data.goods_amount);
		fprintf(fp, "%d\n", p->data.goods_remain);
		p = p->next;
		save_count++;
	}
	fclose(fp);
	return save_count;
}

//--------------------------------------------------------------------
//冒泡排序实现对链表节点的排序，对价格从低到高排序
//--------------------------------------------------------------------
void bubble_sort(GoodsList *L) {
	GoodsList *p;
	GoodsInfo temp;
	int n = CurrentCnt;
	int i, j;

	if (L == NULL || L->next == NULL)
		printf("当前链表中没有商品\n");
	for (j = 1; j < n; ++j) {
		p = L->next;
		for (i = 0; i < n - j; ++i) {
			if (p->data.goods_price > p->next->data.goods_price) {
				temp = p->data;
				p->data = p->next->data;
				p->next->data = temp;
			}
			p = p->next;
		}
	}
}




int main(void)
{
	GoodsList *goodsList;
	init_list(&goodsList);
	GoodsInfo item;
	char temp_id[MAX_ID_LEN];
	while (1) {
		int choice;
		printf("超市商品管理系统\n");
		printf("********************************************\n");
		printf("1.显示所有商品的信息:\n");
		printf("2.修改某个商品的信息:\n");
		printf("3.插入某个商品的信息:\n");
		printf("4.删除某个商品的信息:\n");
		printf("5.查找某个商品的信息:\n");
		printf("6.商品存盘并退出系统:\n");
		printf("7.对商品价格进行排序:\n");
		printf("8.(慎用)删除所有内容:\n");
		printf("其他.不存盘并退出系统:\n");
		printf("********************************************\n");
		printf("输入您的选择: ");

		scanf("%d", &choice);
		switch (choice) {
			case 1:
				output_all_items(goodsList);
				break;
			case 2:
				item = read_goods_info();
				printf("输入要修改记录的 ID：");
				read_line(temp_id, MAX_ID_LEN);
				change_item(goodsList, temp_id, item);
				break;
			case 3:
				item = read_goods_info();
				int pos;
				printf("输入数字表明你要插入的商品位置：0.商品列表尾部 1.商品列表头部 i.商品列表中间第i号位置\n");
				scanf("%d", &pos);
				insert_item(goodsList, item, pos);
				break;
			case 4:
				printf("输入要删除记录的 ID：");
				read_line(temp_id, MAX_ID_LEN);
				delete_item(goodsList, temp_id);
				break;
			case 5:
				printf("输入要查找记录的 ID：");
				read_line(temp_id, MAX_ID_LEN);
				search_item(goodsList, temp_id);
				break;
			case 6:
				save_to_file(goodsList);
				printf("您已经存盘并退出超市商品管理系统!\n");
				return 0;
			case 7:
				bubble_sort(goodsList);
				break;
			case 8:
				destory_list_and_file(&goodsList);
				printf("您已经删除商品文件内容以及链表内容!\n");
				break;
			default:
				printf("您已经退出超市商品管理系统!\n");
				destory_list(&goodsList);
				return 0;
		}
	}
}
